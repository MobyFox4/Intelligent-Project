import streamlit as st
from streamlit_option_menu import option_menu
import pickle
import numpy as np
import tensorflow as tf
import pandas as pd

# Code ML
MLcode1 = "import pandas as pd\ndf = pd.read_csv('../Dataset/mushroom_overload.csv')\ndf"

MLcode2 = "df = df.drop(columns=['gill-spacing','stem-root','stem-surface','veil-type','veil-color','spore-print-color'])\ndf"

MLcode3 = "df.isnull().sum()"

MLcode4 = "df.duplicated().sum()"

MLcode5 = "df=df.dropna()\ndf.drop_duplicates(inplace=True)\ndf"

MLcode6 = """mapping = {
    "cap-shape": {
        "b": 1, "c": 2, "x": 3, "f": 4, "s": 5, "p": 6, "o": 7
    },
    "cap-surface": {
        "i": 1, "g": 2, "y": 3, "s": 4, "d": 5, "h": 6, "l": 7, "k": 8, "t": 9, "w": 10, "e": 11
    },
    "cap-color": {
        "n": 1, "b": 2, "g": 3, "r": 4, "p": 5, "u": 6, "e": 7, "w": 8, "y": 9, "l": 10, "o": 11, "k": 12
    },
    "does-bruise-or-bleed": {
        "t": 1, "f": 0
    },
    "gill-attachment": {
        "a": 1, "x": 2, "d": 3, "e": 4, "s": 5, "p": 6, "f": 7, "?": 8
    },
    "gill-color": {
        "f": 0, "n": 1, "b": 2, "g": 3, "r": 4, "p": 5, "u": 6, "e": 7, "w": 8, "y": 9, "l": 10, "o": 11, "k": 12
    },
    "stem-color": {
        "f": 0, "n": 1, "b": 2, "g": 3, "r": 4, "p": 5, "u": 6, "e": 7, "w": 8, "y": 9, "l": 10, "o": 11, "k": 12
    },
    "has-ring": {
        "t": 1, "f": 0
    },
    "ring-type": {
        "c": 1, "e": 2, "r": 3, "g": 4, "l": 5, "p": 6, "s": 7, "z": 8, "y": 9, "m": 10, "f": 0, "?": 11
    },
    "habitat": {
        "g": 1, "l": 2, "m": 3, "p": 4, "h": 5, "u": 6, "w": 7, "d": 8
    },
    "season": {"s": 1, "u": 2, "a": 3, "w": 4},
    "class": {"e": 1, "p": 0}
}

df.replace(mapping, inplace=True)
df"
"""

MLcode7 = "from sklearn.model_selection import train_test_split\n\nx = df.drop(columns=['class'])\ny = df['class']\n\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)"

MLcode8 = """from sklearn.ensemble import RandomForestClassifier

model_rf = RandomForestClassifier(random_state=42)

# Train the model on the training data
model_rf.fit(x_train, y_train)

# Make predictions on test data
y_pred_rf = model_rf.predict(x_test)

# Confusion matrix
conf_matrix_rf = confusion_matrix(y_test, y_pred_rf)
print("Confusion Matrix (Random Forest):")
print(conf_matrix_rf)

# Accuracy
accuracy_rf = accuracy_score(y_test, y_pred_rf)
print("Accuracy (Random Forest):", accuracy_rf)

# Precision
precision_rf = precision_score(y_test, y_pred_rf)
print("Precision (Random Forest):", precision_rf)

# Recall
recall_rf = recall_score(y_test, y_pred_rf)
print("Recall (Random Forest):", recall_rf)

# F1 Score
f1_rf = f1_score(y_test, y_pred_rf)
print("F1 Score (Random Forest):", f1_rf)"
"""

MLcode9 = """from sklearn.linear_model import LogisticRegression

model_logreg = LogisticRegression()

# Train the model on the training data
model_logreg.fit(x_train, y_train)

# Make predictions on test data
y_pred_logreg = model_logreg.predict(x_test)

# Confusion matrix
conf_matrix_logreg = confusion_matrix(y_test, y_pred_logreg)
print("Confusion Matrix (Logistic Regression):")
print(conf_matrix_logreg)

# Accuracy
accuracy_logreg = accuracy_score(y_test, y_pred_logreg)
print("Accuracy:", accuracy_logreg)

# Precision
precision_logreg = precision_score(y_test, y_pred_logreg)
print("Precision:", precision_logreg)

# Recall
recall_logreg = recall_score(y_test, y_pred_logreg)
print("Recall (LogReg):", recall_logreg)

# F1 Score
f1_logreg = f1_score(y_test, y_pred_logreg)
print("F1 Score (LogReg):", f1_logreg)
"""

# Code NN
NNcode1 = "import tensorflow as tf"

# ‡∏™‡∏£‡πâ‡∏≤‡∏á Navbar ‡∏î‡πâ‡∏≤‡∏ô‡∏ö‡∏ô
page = option_menu(
    menu_title=None,  # ‡∏ã‡πà‡∏≠‡∏ô‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏°‡∏ô‡∏π
    options=["Machine Learning", "Neural Network", "Machine Learning Demo", "Neural Network Model"],
    icons=["cast", "cast", "cast", "cast"],  # ‡πÑ‡∏≠‡∏Ñ‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ
    menu_icon="cast",
    default_index=0,
    orientation="horizontal"  # ‡πÅ‡∏™‡∏î‡∏á Navbar ‡∏î‡πâ‡∏≤‡∏ô‡∏ö‡∏ô
)

mapping = {
    "cap-shape": {"Bell": 1, "Conical": 2, "Convex": 3, "Flat": 4, "Sunken": 5, "Spherical": 6, "Others": 7},
    "cap-surface": {"Fibrous": 1, "Grooves": 2, "Scaly": 3, "Smooth": 4, "Dry": 5, "Shiny": 6, "Leathery": 7, "Silky": 8, "Sticky": 9, "Wrinkled": 10, "Fleshy": 11},
    "cap-color": {"Brown": 1, "Buff": 2, "Gray": 3, "Green": 4, "Pink": 5, "Purple": 6, "Red": 7, "White": 8, "Yellow": 9, "Blue": 10, "Orange": 11, "Black": 12},
    "does-bruise-or-bleed": {"Yes": 1, "No": 0},
    "gill-attachment": {"Adnate": 1, "Adnexed": 2, "Decurrent": 3, "Free": 4, "Sinuate": 5, "Pores": 6, "None": 7, "Unknown": 8},
    "gill-color": {"None": 0, "Brown": 1, "Buff": 2, "Gray": 3, "Green": 4, "Pink": 5, "Purple": 6, "Red": 7, "White": 8, "Yellow": 9, "Blue": 10, "Orange": 11, "Black": 12},
    "stem-color": {"None": 0, "Brown": 1, "Buff": 2, "Gray": 3, "Green": 4, "Pink": 5, "Purple": 6, "Red": 7, "White": 8, "Yellow": 9, "Blue": 10, "Orange": 11, "Black": 12},
    "Has-ring": {"Yes": 1, "No": 0},
    "ring-type": {"Cobwebby": 1, "Evanescent": 2, "Flaring": 3, "Grooved": 4, "Large": 5, "Pendant": 6, "Sheathing": 7, "Zone": 8, "Scaly": 9, "Movable": 10, "None": 0, "Unknown": 11},
    "habitat": {"Grasses": 1, "Leaves": 2, "Meadows": 3, "Paths": 4, "Heaths": 5, "Urban": 6, "Waste": 7, "Woods": 8},
    "season": {"Spring": 1, "Summer": 2, "Autumn": 3, "Winter": 4}
}

type_mapping = {
    "CASH-IN": 0,
    "CASH-OUT": 1,
    "DEBIT": 2,
    "PAYMENT": 3,
    "TRANSFER": 4
}

df = pd.read_csv("Dataset/mushroom_overload.csv", nrows=20)

# ‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤‡∏ï‡∏≤‡∏°‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å
if page == "Machine Learning":
    st.header("üóÇÔ∏è Dataset ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ")
    st.subheader("üçÑMushroom Overload| 6.7M Rows")
    st.markdown("‡πÇ‡∏´‡∏•‡∏î‡∏à‡∏≤‡∏Å Kaggle: https://www.kaggle.com/datasets/bwandowando/mushroom-overload/data")
    st.subheader("üìä ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å Dataset")
    st.dataframe(df.head(20))
    st.subheader("üìÑ Features")
    features_info = """
    - **cap-diameter (m)**: float number in cm  
    - **cap-shape (n)**: bell=b, conical=c, convex=x, flat=f, sunken=s, spherical=p, others=o  
    - **cap-surface (n)**: fibrous=i, grooves=g, scaly=y, smooth=s, dry=d, shiny=h, leathery=l, silky=k, sticky=t, wrinkled=w, fleshy=e  
    - **cap-color (n)**: brown=n, buff=b, gray=g, green=r, pink=p, purple=u, red=e, white=w, yellow=y, blue=l, orange=o, black=k  
    - **does-bruise-bleed (n)**: bruises-or-bleeding=t, no=f  
    - **gill-attachment (n)**: adnate=a, adnexed=x, decurrent=d, free=e, sinuate=s, pores=p, none=f, unknown=?  
    - **gill-spacing (n)**: close=c, distant=d, none=f  
    - **gill-color (n)**: see cap-color + none=f  
    - **stem-height (m)**: float number in cm  
    - **stem-width (m)**: float number in mm  
    - **stem-root (n)**: bulbous=b, swollen=s, club=c, cup=u, equal=e, rhizomorphs=z, rooted=r  
    - **stem-surface (n)**: see cap-surface + none=f  
    - **stem-color (n)**: see cap-color + none=f  
    - **veil-type (n)**: partial=p, universal=u  
    - **veil-color (n)**: see cap-color + none=f  
    - **has-ring (n)**: ring=t, none=f  
    - **ring-type (n)**: cobwebby=c, evanescent=e, flaring=r, grooved=g, large=l, pendant=p, sheathing=s, zone=z, scaly=y, movable=m, none=f, unknown=?  
    - **spore-print-color (n)**: see cap-color  
    - **habitat (n)**: grasses=g, leaves=l, meadows=m, paths=p, heaths=h, urban=u, waste=w, woods=d  
    - **season (n)**: spring=s, summer=u, autumn=a, winter=w  
    - **class (n)**: e=edible, p=poisonous  
    """
    
    st.markdown(features_info)
    st.header("üìù ‡∏Å‡∏≤‡∏£‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•")
    st.text("‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å‡∏ô‡∏≥‡πÄ‡∏Ç‡πâ‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• DataSet ‡∏ó‡∏µ‡πà‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤‡πÄ‡∏Å‡πá‡∏ö‡πÑ‡∏ß‡πâ‡πÉ‡∏ô‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£ df")
    st.code(MLcode1, language="python")
    st.image("Streamlit/image/ML/ML1.png")
    
    st.text("")
    st.text("‡∏à‡∏≤‡∏Å‡∏ô‡∏±‡πâ‡∏ô drop ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏à‡∏≥‡πÅ‡∏ô‡∏Å‡πÄ‡∏´‡πá‡∏î‡∏û‡∏¥‡∏©‡∏≠‡∏≠‡∏Å‡πÑ‡∏õ")
    st.code(MLcode2, language="python")
    st.image("Streamlit/image/ML/ML2.png")
    
    st.text("")
    st.text("‡∏ï‡πà‡∏≠‡∏°‡∏≤‡∏Å‡πá‡∏ó‡∏≥‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡πá‡∏Ñ‡∏î‡∏π‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô Null ‡πÅ‡∏•‡∏∞‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏ã‡πâ‡∏≥‡∏Å‡∏±‡∏ô‡πÑ‡∏´‡∏°")
    st.code(MLcode3, language="python")
    st.image("Streamlit/image/ML/ML3.png")
    st.code(MLcode4, language="python")
    st.image("Streamlit/image/ML/ML4.png")
    
    st.text("")
    st.text("‡∏à‡∏∞‡πÄ‡∏´‡πá‡∏ô‡πÑ‡∏î‡πâ‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô Null ‡πÅ‡∏•‡∏∞‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏ã‡πâ‡∏≥‡∏Å‡∏±‡∏ô‡∏≠‡∏¢‡∏π‡πà‡∏à‡∏≤‡∏Å‡∏ô‡∏±‡πâ‡∏ô‡∏ó‡∏≥‡∏Å‡∏≤‡∏£ Drop ‡πÅ‡∏ñ‡∏ß‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô Null ‡πÅ‡∏•‡∏∞‡πÅ‡∏ñ‡∏ß‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ã‡πâ‡∏≥‡∏ó‡∏¥‡πâ‡∏á‡∏≠‡∏≠‡∏Å‡πÑ‡∏õ‡πÑ‡∏î‡πâ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡πÄ‡∏£‡∏≤‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏°‡∏≤‡∏Å‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÄ‡∏õ‡πá‡∏ô Null ‡πÅ‡∏•‡∏∞ ‡πÑ‡∏°‡πà‡∏ã‡πâ‡∏≥‡∏Å‡∏±‡∏ô")
    st.code(MLcode5, language="python")
    st.image("Streamlit/image/ML/ML5.png")
    
    st.text("")
    st.text("‡∏à‡∏≤‡∏Å‡∏ô‡∏±‡πâ‡∏ô‡∏Å‡πá‡πÅ‡∏õ‡∏•‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡∏á‡πà‡∏≤‡∏¢‡∏ï‡πà‡∏≠‡∏Å‡∏≤‡∏£‡∏ô‡∏≥‡πÑ‡∏õ‡πÄ‡∏ó‡∏£‡∏ô‡πÇ‡∏°‡πÄ‡∏î‡∏•")
    st.code(MLcode6, language="python")
    st.image("Streamlit/image/ML/ML6.png")
    
    st.text("")
    st.text("‡∏à‡∏≤‡∏Å‡∏ô‡∏±‡πâ‡∏ô‡∏ó‡∏≥‡∏Å‡∏≤‡∏£‡πÅ‡∏ö‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏≠‡∏Å‡πÄ‡∏õ‡πá‡∏ô‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏ù‡∏∂‡∏Å 80% ‡πÅ‡∏•‡∏∞‡πÉ‡∏ä‡πâ‡∏ó‡∏î‡∏™‡∏≠‡∏ö 20% ‡πÇ‡∏î‡∏¢‡πÉ‡∏´‡πâ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏Å‡πá‡∏ö‡πÑ‡∏ß‡πâ‡πÉ‡∏ô y ‡∏ã‡∏∂‡πà‡∏á‡∏Å‡πá‡∏Ñ‡∏∑‡∏≠ class ‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡∏ö‡∏≠‡∏Å‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏´‡πá‡∏î‡∏û‡∏¥‡∏©‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà ‡πÅ‡∏•‡∏∞‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡πÑ‡∏ß‡πâ‡πÉ‡∏ô x")
    st.code(MLcode7, language="python")
    
    st.text("‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏ï‡∏±‡∏ß‡πÅ‡∏£‡∏Å‡∏à‡∏∞‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÉ‡∏ä‡πâ Random Forest ‡∏ã‡∏∂‡πà‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏≠‡∏±‡∏•‡∏Å‡∏≠‡∏£‡∏¥‡∏ò‡∏∂‡∏°‡∏Ç‡∏≠‡∏á Machine Learning ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Classification ‡∏ã‡∏∂‡πà‡∏á‡∏ß‡∏¥‡∏ò‡∏µ‡∏Å‡∏≤‡∏£‡∏Ç‡∏≠‡∏á Random Forest ‡∏à‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á Dicision Trees ‡∏≠‡∏≠‡∏Å‡∏°‡∏≤‡∏´‡∏•‡∏≤‡∏¢‡πÜ‡∏ï‡πâ‡∏ô‡∏≠‡∏≠‡∏Å‡∏°‡∏≤‡πÅ‡∏•‡πâ‡∏ß‡∏à‡∏∞‡∏ô‡∏≥‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡∏à‡∏≤‡∏Å Dicision Trees ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏°‡∏≤‡πÄ‡∏ä‡πá‡∏Ñ‡∏î‡∏π‡∏ß‡πà‡∏≤‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏ó‡∏µ‡πà‡∏≠‡∏≠‡∏Å‡∏°‡∏≤‡∏™‡πà‡∏ß‡∏ô‡πÉ‡∏´‡∏ç‡πà‡πÄ‡∏õ‡πá‡∏ô‡∏≠‡∏∞‡πÑ‡∏£ ‡πÅ‡∏•‡πâ‡∏ß‡∏à‡∏∞‡πÉ‡∏´‡πâ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏™‡πà‡∏ß‡∏ô‡πÉ‡∏´‡∏ç‡πà‡∏ô‡∏±‡πâ‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö‡∏≠‡∏≠‡∏Å‡∏°‡∏≤ ‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏≠‡∏≠‡∏Å‡∏°‡∏≤‡πÅ‡∏•‡πâ‡∏ß‡∏Å‡πá‡∏•‡∏≠‡∏á‡∏ó‡∏≥‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡πÇ‡∏°‡πÄ‡∏î‡∏•‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏Ñ‡πà‡∏≤ Confusion Matrix ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÅ‡∏™‡∏î‡∏á‡∏à‡∏≥‡∏ô‡∏ß‡∏ô ‡∏Ñ‡πà‡∏≤‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡πÅ‡∏•‡∏∞‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î | Accuracy ‡πÉ‡∏ä‡πâ‡∏ß‡∏±‡∏î‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥‡∏Ç‡∏≠‡∏á‡πÇ‡∏°‡πÄ‡∏î‡∏• | Precision ‡πÉ‡∏ä‡πâ‡∏ß‡∏±‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥‡∏Ç‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡∏ú‡∏• | Recall ‡πÉ‡∏ä‡πâ‡∏ß‡∏±‡∏î‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á | F1 Score ‡πÉ‡∏ä‡πâ‡∏ß‡∏±‡∏î‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏°‡∏î‡∏∏‡∏•‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á Precision ‡πÅ‡∏•‡∏∞ Recall")
    st.code(MLcode8, language="python")
    st.image("Streamlit/image/ML/ML7.png")
    
    st.text("")
    st.text("‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏ó‡∏µ‡πà‡∏™‡∏≠‡∏á‡∏à‡∏∞‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÉ‡∏ä‡πâ Logistic Regression ‡πÄ‡∏õ‡πá‡∏ô‡∏≠‡∏±‡∏•‡∏Å‡∏≠‡∏£‡∏¥‡∏ò‡∏∂‡∏°‡∏Ç‡∏≠‡∏á Machine Learning ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Classification ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏Å‡∏±‡∏ô ‡∏ß‡∏¥‡∏ò‡∏µ‡∏Å‡∏≤‡∏£‡∏Ç‡∏≠‡∏á Logistic Regression ‡∏à‡∏∞‡πÉ‡∏ä‡πâ‡∏™‡∏°‡∏Å‡∏≤‡∏£‡πÄ‡∏™‡πâ‡∏ô‡∏ï‡∏£‡∏á ‡πÅ‡∏•‡πâ‡∏ß‡∏ô‡∏≥‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡πÑ‡∏õ‡∏ú‡πà‡∏≤‡∏ô‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô Sigmoid ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÅ‡∏õ‡∏•‡∏á‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ô‡πà‡∏≤‡∏à‡∏∞‡πÄ‡∏õ‡πá‡∏ô ‡πÅ‡∏•‡πâ‡∏ß‡∏ï‡∏±‡∏î‡∏™‡∏¥‡∏ô‡∏ß‡πà‡∏≤‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏Å‡∏•‡∏∏‡πà‡∏°‡πÑ‡∏´‡∏ô ‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏≠‡∏≠‡∏Å‡∏°‡∏≤‡πÅ‡∏•‡πâ‡∏ß‡∏Å‡πá‡∏•‡∏≠‡∏á‡∏ó‡∏≥‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡πÇ‡∏°‡πÄ‡∏î‡∏•‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏Ñ‡πà‡∏≤ Confusion Matrix, Accuracy, Precision, Recall, ‡πÅ‡∏•‡∏∞ F1 Score ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏Å‡∏±‡∏ö‡πÇ‡∏°‡πÄ‡∏î‡∏•‡πÅ‡∏£‡∏Å")
    st.code(MLcode9, language="python")
    st.image("Streamlit/image/ML/ML8.png")

    st.text("")
    st.text("‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£‡πÄ‡∏ó‡∏£‡∏ô‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏™‡∏≠‡∏á‡πÅ‡∏ö‡∏ö‡∏à‡∏∞‡πÄ‡∏´‡πá‡∏ô‡πÑ‡∏î‡πâ‡∏ß‡πà‡∏≤‡∏≠‡∏±‡∏•‡∏Å‡∏≠‡∏£‡∏¥‡∏ò‡∏∂‡∏°‡πÅ‡∏ö‡∏ö Random Forest ‡∏à‡∏∞‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤ Logistic Regression ‡∏≠‡∏¢‡∏π‡πà‡∏°‡∏≤‡∏Å‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ Dicision trees ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏°‡∏≤‡∏Å‡∏°‡∏≤‡πÉ‡∏ä‡πâ‡πÇ‡∏´‡∏ß‡∏ï‡∏ï‡∏±‡∏î‡∏™‡∏¥‡∏ô‡πÉ‡∏à")
    
elif page == "Neural Network":
    st.title("üß† Neural Network üß†")
    st.write("üõ†Ô∏è maintenance üõ†Ô∏è")
    
elif page == "Machine Learning Demo":
    st.title("üçÑ Machine Learning DemoüçÑ ")
    st.write("‡∏Å‡∏£‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡πÄ‡∏´‡πá‡∏î‡∏û‡∏¥‡∏©‡∏à‡∏≤‡∏Å‡∏•‡∏±‡∏Å‡∏©‡∏ì‡∏∞‡∏Ç‡∏≠‡∏á‡πÄ‡∏´‡πá‡∏î")
    
    # ‡∏£‡∏±‡∏ö‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ
    cap_diameter = st.number_input("Cap Diameter (cm)", min_value=0.1, max_value=100.0, step=0.1)
    stem_height = st.number_input("Stem Height (cm)", min_value=0.1, max_value=100.0, step=0.1)
    stem_width = st.number_input("Stem Width (mm)", min_value=0.1, max_value=100.0, step=0.1)
    cap_shape = st.selectbox("Cap Shape", options=list(mapping["cap-shape"].keys()))
    cap_surface = st.selectbox("Cap Surface", options=list(mapping["cap-surface"].keys()))
    cap_color = st.selectbox("Cap Color", options=list(mapping["cap-color"].keys()))
    does_bruise_or_bleed = st.selectbox("Does Bruise or Bleed", options=list(mapping["does-bruise-or-bleed"].keys()))
    gill_attachment = st.selectbox("Gill Attachment", options=list(mapping["gill-attachment"].keys()))
    gill_color = st.selectbox("Gill Color", options=list(mapping["gill-color"].keys()))
    stem_color = st.selectbox("Stem Color", options=list(mapping["stem-color"].keys()))
    Has_ring = st.selectbox("Has Ring", options=list(mapping["Has-ring"].keys()))
    ring_type = st.selectbox("Ring Type", options=list(mapping["ring-type"].keys()))
    habitat = st.selectbox("Habitat", options=list(mapping["habitat"].keys()))
    season = st.selectbox("Season", options=list(mapping["season"].keys()))
    
    model_choice = st.selectbox("‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÇ‡∏°‡πÄ‡∏î‡∏•", options=["Logistic Regression", "Random Forest"], index=0)
    
    if st.button("Predict"):
        model_path = "Model/mushroom_model_logreg.pkl" if model_choice == "Logistic Regression" else "Model/mushroom_model_RandomForest.pkl"
        with open(model_path, "rb") as file:
            model = pickle.load(file)
        
        input_data = np.array([[cap_diameter, mapping["cap-shape"][cap_shape], mapping["cap-surface"][cap_surface], 
                                mapping["cap-color"][cap_color], mapping["does-bruise-or-bleed"][does_bruise_or_bleed], 
                                mapping["gill-attachment"][gill_attachment], mapping["gill-color"][gill_color], 
                                stem_height, stem_width, mapping["stem-color"][stem_color], 
                                mapping["Has-ring"][Has_ring], mapping["ring-type"][ring_type], 
                                mapping["habitat"][habitat], mapping["season"][season]]])
        
        prediction = model.predict(input_data)
        result = "üçÑ ‡πÄ‡∏õ‡πá‡∏ô‡∏û‡∏¥‡∏©" if prediction[0] == 1 else "‚úÖ ‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢"
        st.success(f"‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå: {result}")

    
elif page == "Neural Network Model":
    st.title("ü§ñ Neural Network Demo ü§ñ")
    st.write("‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô ‡∏´‡∏°‡∏≤ ‡∏´‡∏£‡∏∑‡∏≠ ‡πÅ‡∏°‡∏ß")
    
    step = st.number_input("Step", min_value=0, step=1)
    type_ = st.selectbox("Transaction Type", options=list(type_mapping.values()), format_func=lambda x: list(type_mapping.keys())[list(type_mapping.values()).index(x)])
    amount = st.number_input("Amount", min_value=0.0, step=0.01)
    oldbalanceOrg = st.number_input("Old Balance Origin", min_value=0.0, step=0.01)
    newbalanceOrig = st.number_input("New Balance Origin", min_value=0.0, step=0.01)
    oldbalanceDest = st.number_input("Old Balance Destination", min_value=0.0, step=0.01)
    newbalanceDest = st.number_input("New Balance Destination", min_value=0.0, step=0.01)
    
    if st.button("Predict"):
        model = tf.keras.models.load_model("Model/fraud_detection_model.keras")
        input_data = np.array([[step, type_, amount, oldbalanceOrg, newbalanceOrig, oldbalanceDest, newbalanceDest]])
        prediction = model.predict(input_data)
        result = "üö® Fraud Detected" if prediction[0] > 0.5 else "‚úÖ No Fraud"
        st.success(f"‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå: {result}")


